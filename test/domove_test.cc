#include "board.h"
#include "defs.h"
#include "cmove.h"
#include "catch.hpp"
#include <iostream>

TEST_CASE("Board::doMove works properly") {
  Board board;

  SECTION("doMove moves pawns up from the starting position for white") {
    board.setToStartPos();

    CMove move(a2, a4, PAWN);

    board.doMove(move);

    REQUIRE( (board.getWhiteBitBoard(PAWN) & (ONE << a4)) );
  }

  SECTION("doMove moves pawns up from the starting position for black") {
    board.setToFen("rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq -");

    CMove move(a7, a5, PAWN);

    board.doMove(move);

    REQUIRE( (board.getBlackBitBoard(PAWN) & (ONE << a5)) );
  }

  SECTION("doMove handles captures") {
    board.setToFen("8/8/8/4n3/8/2B5/8/8 w - -");

    CMove move(c3, e5, BISHOP, CMove::CAPTURE);

    board.doMove(move);

    REQUIRE( (board.getWhiteBitBoard(BISHOP) & (ONE << e5)) );
    REQUIRE(board.getBlackBitBoard(KNIGHT) == ZERO);
  }

  SECTION("doMove handles en passant for black") {
    board.setToFen("8/8/8/8/2Pp4/8/8/8 b kq c3");

    CMove move(d4, c3, PAWN, CMove::EN_PASSANT);

    board.doMove(move);

    REQUIRE( (board.getBlackBitBoard(PAWN) & (ONE << c3)) );
    REQUIRE(board.getWhiteBitBoard(PAWN) ==ZERO);
    REQUIRE(board.EN_PASSANT ==ZERO);
  }

  SECTION("doMove handles en passant for white") {
    board.setToFen("8/8/8/2pP4/8/8/8/8 w kq c6");

    CMove move(d5, c6, PAWN, CMove::EN_PASSANT);

    board.doMove(move);

    REQUIRE( (board.getWhiteBitBoard(PAWN) & (ONE << c6)) );
    REQUIRE(board.getBlackBitBoard(PAWN) ==ZERO);
    REQUIRE(board.EN_PASSANT ==ZERO);
  }

  SECTION("doMove handles white kingside castles") {
    board.setToFen("8/8/8/8/8/8/8/4K2R w - -");
    CMove move(e1, g1, KING, CMove::KSIDE_CASTLE);

    board.doMove(move);
    REQUIRE( (board.getWhiteBitBoard(KING) & (ONE << g1)) );
    REQUIRE( (board.getWhiteBitBoard(ROOK) & (ONE << f1)) );
  }

  SECTION("doMove handles white queenside castles") {
    board.setToFen("8/8/8/8/8/8/8/4K2R w - -");
    CMove move(e1, c1, KING, CMove::QSIDE_CASTLE);

    board.doMove(move);

    REQUIRE( (board.getWhiteBitBoard(KING) & (ONE << c1)) );
    REQUIRE( (board.getWhiteBitBoard(ROOK) & (ONE << d1)) );
  }

  SECTION("doMove handles black kingside castles") {
    board.setToFen("4k2r/8/8/8/8/8/8/8 b - -");
    CMove move(e8, g8, KING, CMove::KSIDE_CASTLE);

    board.doMove(move);

    REQUIRE( (board.getBlackBitBoard(KING) & (ONE << g8)) );
    REQUIRE( (board.getBlackBitBoard(ROOK) & (ONE << f8)) );
  }

  SECTION("doMove handles black queenside castles") {
    board.setToFen("r3k3/8/8/8/8/8/8/8 b - -");
    CMove move(e8, c8, QUEEN, CMove::QSIDE_CASTLE);

    board.doMove(move);

    REQUIRE( (board.getBlackBitBoard(KING) & (ONE << c8)) );
    REQUIRE( (board.getBlackBitBoard(ROOK) & (ONE << d8)) );
  }

  SECTION("White cannot castle after moving its king") {
    board.setToFen("8/8/8/8/8/8/8/4K2R w KQ -");

    REQUIRE(board.whiteCanCastleKs() == true);
    REQUIRE(board.whiteCanCastleQs() == true);

    CMove move(e1, e2, KING);
    board.doMove(move);

    REQUIRE(board.whiteCanCastleKs() == false);
    REQUIRE(board.whiteCanCastleQs() == false);
  }

  SECTION("Black cannot castle after moving its king") {
    board.setToFen("4k2r/8/8/8/8/8/8/8 w kq -");

    REQUIRE(board.blackCanCastleKs() == true);
    REQUIRE(board.blackCanCastleQs() == true);

    CMove move(e8, e7, KING);
    board.doMove(move);

    REQUIRE(board.blackCanCastleKs() == false);
    REQUIRE(board.blackCanCastleQs() == false);
  }

  SECTION("doMove works with white promotions") {
    board.setToFen("8/3P4/8/8/8/8/8/8 w - -");

    CMove move(d7, d8, PAWN, CMove::QUEEN_PROMOTION);

    board.doMove(move);

    REQUIRE(board.getWhiteBitBoard(PAWN) == ZERO);
    REQUIRE(board.getWhiteBitBoard(QUEEN) == (ONE << d8));
  }

  SECTION("doMove works with black promotions") {
    board.setToFen("8/8/8/8/8/8/3p4/8 b - -");

    CMove move(d2, d1, PAWN, CMove::QUEEN_PROMOTION);

    board.doMove(move);

    REQUIRE(board.getBlackBitBoard(PAWN) ==ZERO);
    REQUIRE(board.getBlackBitBoard(QUEEN) == (ONE << d1));
  }

  SECTION("doMove works with white capture promotions") {
    board.setToFen("2q5/3P4/8/8/8/8/8/8 w - -");

    CMove move(d7, c8, PAWN, CMove::CAPTURE | CMove::KNIGHT_PROMOTION);
    board.doMove(move);

    REQUIRE(board.getWhiteBitBoard(PAWN) == ZERO);
    REQUIRE(board.getBlackBitBoard(QUEEN) == ZERO);
    REQUIRE(board.getWhiteBitBoard(KNIGHT) == (ONE << c8));
  }

  SECTION("doMove works with black capture promotions") {
    board.setToFen("8/8/8/8/8/8/3p4/2Q5 b - -");

    CMove move(d2, c1, PAWN, CMove::CAPTURE | CMove::KNIGHT_PROMOTION);
    board.doMove(move);

    REQUIRE(board.getBlackBitBoard(PAWN) == ZERO);
    REQUIRE(board.getBlackBitBoard(KNIGHT) == (ONE << c1));
    REQUIRE(board.getWhiteBitBoard(QUEEN) == ZERO);
  }

  SECTION("doMove should update the en passant square after a double pawn push for white") {
    board.setToStartPos();

    CMove move(a2, a4, PAWN, CMove::DOUBLE_PAWN_PUSH);
    board.doMove(move);

    REQUIRE(board.EN_PASSANT == (ONE << a3));
  }

  SECTION("doMove should update the en passant square after a double pawn push for black") {
    board.setToFen("rnbqkbnr/pppppppp/8/8/3P4/8/PPP1PPPP/RNBQKBNR b KQkq -");

    CMove move(a7, a5, PAWN, CMove::DOUBLE_PAWN_PUSH);
    board.doMove(move);

    REQUIRE(board.EN_PASSANT == (ONE << a6));
  }
}
